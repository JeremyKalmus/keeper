#!/bin/bash
# hooks/post-bead-create - Post-bead-create hook for Keeper of the Seeds
#
# This hook appends Keeper guidance to newly created beads by analyzing
# the bead title/description against seed registries.
#
# Usage:
#   Called by `bd create` after a bead is created.
#   The hook receives bead context via environment variables.
#
# Environment variables (set by bd create):
#   BD_BEAD_ID          - ID of the newly created bead
#   BD_BEAD_TITLE       - Title of the bead
#   BD_BEAD_DESCRIPTION - Description of the bead (may be empty)
#   BD_BEAD_TYPE        - Type of bead (task, bug, feature)
#   GT_RIG_ROOT         - Path to the rig root directory
#   GT_TOWN_ROOT        - Path to the town root directory
#
# Exit codes:
#   0 - Success (guidance appended)
#   0 - No seeds found (silent success, no guidance needed)
#   1 - Error (failed to append guidance)
#
# The Keeper of the Seeds provides guidance before work begins.

set -euo pipefail

# Configuration
SEEDS_DIR="${GT_RIG_ROOT:-$(pwd)}/seeds"
DECISIONS_DIR="${GT_RIG_ROOT:-$(pwd)}/decisions"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

log_error() {
    echo -e "${RED}[post-bead-create] ERROR: $1${NC}" >&2
}

log_warn() {
    echo -e "${YELLOW}[post-bead-create] WARNING: $1${NC}" >&2
}

log_success() {
    echo -e "${GREEN}[post-bead-create] $1${NC}"
}

log_info() {
    echo "[post-bead-create] $1"
}

# Check if keeper is enabled for this rig
check_keeper_enabled() {
    local keeper_config="${GT_RIG_ROOT:-$(pwd)}/keeper.yaml"
    [[ -f "$keeper_config" ]]
}

# Get keeper mode
get_keeper_mode() {
    local keeper_config="${GT_RIG_ROOT:-$(pwd)}/keeper.yaml"

    if [[ -f "$keeper_config" ]]; then
        local mode
        mode=$(grep -E '^\s*mode:\s*' "$keeper_config" 2>/dev/null | head -1 | sed 's/.*mode:\s*//' | tr -d '[:space:]"'"'" | tr '[:upper:]' '[:lower:]')
        echo "${mode:-growth}"
    else
        echo "growth"
    fi
}

# Extract keywords from text for matching
extract_keywords() {
    local text="$1"
    # Convert to lowercase, extract words, remove common stop words
    echo "$text" | tr '[:upper:]' '[:lower:]' | \
        tr -cs '[:alnum:]' '\n' | \
        grep -vE '^(the|a|an|to|for|of|in|on|is|are|and|or|with|that|this|it|as|be|at|by)$' | \
        sort -u
}

# Search seed files for matching patterns
search_seeds() {
    local keywords="$1"
    local seed_type="$2"
    local seed_file="${SEEDS_DIR}/${seed_type}.yaml"
    local matches=""

    if [[ ! -f "$seed_file" ]]; then
        return
    fi

    # For frontend - look for component names
    if [[ "$seed_type" == "frontend" ]]; then
        # Extract all component names (lines starting with 2 spaces then capital letter)
        local all_components
        all_components=$(grep -E '^  [A-Z][a-zA-Z]+:' "$seed_file" 2>/dev/null | sed 's/:.*//' | sed 's/^  //')

        for keyword in $keywords; do
            # Check if any component name contains this keyword (case-insensitive)
            for comp in $all_components; do
                if echo "$comp" | grep -qi "$keyword"; then
                    matches="${matches}${comp}"$'\n'
                fi
            done
        done
    fi

    # For backend - look for services
    if [[ "$seed_type" == "backend" ]]; then
        local all_services
        all_services=$(grep -E '^  [A-Z][a-zA-Z]+Service:' "$seed_file" 2>/dev/null | sed 's/:.*//' | sed 's/^  //')
        all_services="${all_services}"$'\n'$(grep -E '^  [A-Z]+ /' "$seed_file" 2>/dev/null | sed 's/:.*//' | sed 's/^  //' | head -5)

        for keyword in $keywords; do
            for svc in $all_services; do
                if echo "$svc" | grep -qi "$keyword"; then
                    matches="${matches}${svc}"$'\n'
                fi
            done
        done
    fi

    # For data - look for tables and enums
    if [[ "$seed_type" == "data" ]]; then
        local all_items
        all_items=$(grep -E '^  [a-z_]+:' "$seed_file" 2>/dev/null | sed 's/:.*//' | sed 's/^  //')

        for keyword in $keywords; do
            for item in $all_items; do
                if echo "$item" | grep -qi "$keyword"; then
                    matches="${matches}${item}"$'\n'
                fi
            done
        done
    fi

    # For auth - look for scopes and roles
    if [[ "$seed_type" == "auth" ]]; then
        local all_items
        all_items=$(grep -E '^  [a-z:]+:' "$seed_file" 2>/dev/null | grep -v '^\s*#' | sed 's/:.*//' | sed 's/^  //')

        for keyword in $keywords; do
            for item in $all_items; do
                if echo "$item" | grep -qi "$keyword"; then
                    matches="${matches}${item}"$'\n'
                fi
            done
        done
    fi

    echo "$matches" | grep -v '^$' | sort -u | head -5
}

# Analyze title and description against seeds
analyze_bead() {
    local title="${BD_BEAD_TITLE:-}"
    local description="${BD_BEAD_DESCRIPTION:-}"
    local combined="${title} ${description}"

    local keywords
    keywords=$(extract_keywords "$combined")

    # Detect which domains are relevant
    local frontend_matches="" backend_matches="" data_matches="" auth_matches=""

    # Check for frontend-related keywords
    if echo "$keywords" | grep -qE '(button|modal|input|card|ui|component|form|dialog|page|view|screen|render|click|submit)'; then
        frontend_matches=$(search_seeds "$keywords" "frontend")
    fi

    # Check for backend-related keywords
    if echo "$keywords" | grep -qE '(api|route|service|endpoint|server|controller|handler|request|response|post|get|patch|delete)'; then
        backend_matches=$(search_seeds "$keywords" "backend")
    fi

    # Check for data-related keywords
    if echo "$keywords" | grep -qE '(table|schema|enum|database|migration|query|index|constraint|field|column|record)'; then
        data_matches=$(search_seeds "$keywords" "data")
    fi

    # Check for auth-related keywords
    if echo "$keywords" | grep -qE '(auth|login|logout|token|session|jwt|scope|permission|role|user|credential|password)'; then
        auth_matches=$(search_seeds "$keywords" "auth")
    fi

    # Output matches by category
    echo "FRONTEND:${frontend_matches}"
    echo "BACKEND:${backend_matches}"
    echo "DATA:${data_matches}"
    echo "AUTH:${auth_matches}"
}

# Generate guidance markdown based on analysis
generate_guidance() {
    local analysis="$1"
    local guidance=""
    local reuse="" extend="" create="" location="" pattern=""

    # Parse analysis results
    local frontend backend data auth
    frontend=$(echo "$analysis" | grep "^FRONTEND:" | sed 's/^FRONTEND://' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g' | sed 's/^,//')
    backend=$(echo "$analysis" | grep "^BACKEND:" | sed 's/^BACKEND://' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g' | sed 's/^,//')
    data=$(echo "$analysis" | grep "^DATA:" | sed 's/^DATA://' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g' | sed 's/^,//')
    auth=$(echo "$analysis" | grep "^AUTH:" | sed 's/^AUTH://' | tr '\n' ',' | sed 's/,$//' | sed 's/,,*/,/g' | sed 's/^,//')

    # Build reuse recommendations
    if [[ -n "$frontend" ]]; then
        reuse="${reuse}frontend: ${frontend}; "
        location="${location}src/ui/; "
        pattern="${pattern}Check existing components in seeds/frontend.yaml; "
    fi
    if [[ -n "$backend" ]]; then
        reuse="${reuse}backend: ${backend}; "
        location="${location}src/services/; "
        pattern="${pattern}Follow patterns in seeds/backend.yaml; "
    fi
    if [[ -n "$data" ]]; then
        reuse="${reuse}data: ${data}; "
        location="${location}src/models/; "
        pattern="${pattern}Check schemas in seeds/data.yaml; "
    fi
    if [[ -n "$auth" ]]; then
        reuse="${reuse}auth: ${auth}; "
        location="${location}src/auth/; "
        pattern="${pattern}Follow auth patterns in seeds/auth.yaml; "
    fi

    # Clean up trailing semicolons
    reuse=$(echo "$reuse" | sed 's/; $//')
    location=$(echo "$location" | sed 's/; $//')
    pattern=$(echo "$pattern" | sed 's/; $//')

    # Determine if this is mostly extension or new creation
    if [[ -n "$reuse" ]]; then
        extend="Compose existing patterns before creating new abstractions"
        create="Only if no existing pattern fits after review"
    else
        extend="N/A - no matching seeds found"
        create="Check with Keeper before creating new patterns"
        location="To be determined based on domain"
        pattern="Review seeds/*.yaml for similar patterns"
    fi

    # Build markdown output
    cat << EOF
## Keeper Guidance
**Reuse:** ${reuse:-None identified - review seeds/*.yaml}
**Extend:** ${extend}
**Create:** ${create}
**Location:** ${location}
**Pattern:** ${pattern}
EOF
}

# Append guidance to bead description
append_to_bead() {
    local bead_id="$1"
    local guidance="$2"

    # Get current description
    local current_desc
    current_desc=$(bd show "$bead_id" --format=json 2>/dev/null | grep -o '"description":"[^"]*"' | sed 's/"description":"\(.*\)"/\1/' || echo "")

    # Append guidance (use bd update with appended description)
    local new_desc="${current_desc}

${guidance}"

    # Use bd update to set new description
    # Note: bd update --description requires proper escaping
    bd update "$bead_id" --description="$new_desc" 2>/dev/null
}

# Create decision record
create_decision_record() {
    local bead_id="$1"
    local guidance="$2"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)

    # Ensure decisions directory exists
    mkdir -p "$DECISIONS_DIR"

    local decision_file="${DECISIONS_DIR}/${bead_id}_${timestamp}.yaml"

    cat > "$decision_file" << EOF
# Keeper Decision Record
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# Bead: ${bead_id}

keeper_decision:
  bead_id: "${bead_id}"
  bead_title: "${BD_BEAD_TITLE:-}"
  generated_at: "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  status: pending_review

  # Analysis-based recommendations
  recommendations:
$(echo "$guidance" | sed 's/^/    /')

  # To be filled by reviewer
  approval:
    status: pending  # pending, approved, rejected, deferred
    reviewer: ""
    reviewed_at: ""
    notes: ""
EOF

    echo "$decision_file"
}

# Main logic
main() {
    local bead_id="${BD_BEAD_ID:-}"

    if [[ -z "$bead_id" ]]; then
        log_warn "No BD_BEAD_ID provided, skipping guidance"
        exit 0
    fi

    # Check if keeper is enabled
    if ! check_keeper_enabled; then
        log_info "Keeper not configured in this rig, skipping"
        exit 0
    fi

    local keeper_mode
    keeper_mode=$(get_keeper_mode)

    log_info "Analyzing bead ${bead_id} (keeper mode: ${keeper_mode})..."

    # Analyze the bead
    local analysis
    analysis=$(analyze_bead)

    # Generate guidance
    local guidance
    guidance=$(generate_guidance "$analysis")

    if [[ -z "$guidance" ]]; then
        log_info "No specific guidance generated"
        exit 0
    fi

    # Append guidance to bead
    if append_to_bead "$bead_id" "$guidance"; then
        log_success "Guidance appended to ${bead_id}"
    else
        log_warn "Could not append guidance to bead (continuing anyway)"
    fi

    # Create decision record
    local decision_file
    decision_file=$(create_decision_record "$bead_id" "$guidance")
    log_info "Decision record: ${decision_file}"

    log_success "Keeper guidance complete for ${bead_id}"
    exit 0
}

# Support --help flag
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    cat << 'EOF'
post-bead-create - Keeper of the Seeds guidance hook

This hook automatically appends Keeper guidance to newly created beads
by analyzing the title and description against seed registries.

USAGE:
    hooks/post-bead-create [--help]

ENVIRONMENT VARIABLES:
    BD_BEAD_ID          ID of the newly created bead
    BD_BEAD_TITLE       Title of the bead
    BD_BEAD_DESCRIPTION Description of the bead
    BD_BEAD_TYPE        Type of bead (task, bug, feature)
    GT_RIG_ROOT         Path to the rig root directory
    GT_TOWN_ROOT        Path to the town root directory

EXIT CODES:
    0 - Success (always exits 0 to not block bead creation)
    1 - Reserved for future error conditions

GUIDANCE FORMAT:
    ## Keeper Guidance
    **Reuse:** [existing patterns identified]
    **Extend:** [patterns that could be extended]
    **Create:** [guidance on new pattern creation]
    **Location:** [where code should go]
    **Pattern:** [which existing code to follow]

SEED FILES:
    seeds/frontend.yaml - UI components
    seeds/backend.yaml  - API routes and services
    seeds/data.yaml     - Enums and schemas
    seeds/auth.yaml     - Auth patterns and scopes

KEEPER MODES:
    seeding      - Early project: minimal guidance
    growth       - Default: balanced guidance
    conservation - Mature: strict guidance

EXAMPLE:
    # Bead created with title "Add user profile modal"
    # Hook analyzes and finds:
    #   - Modal component in frontend.yaml
    #   - UserService in backend.yaml
    #   - user:read scope in auth.yaml
    # Appends guidance to use existing patterns

SEE ALSO:
    hooks/pre-convoy - Convoy gate hook
    keeper-spec.md   - Full Keeper specification
EOF
    exit 0
fi

main "$@"
